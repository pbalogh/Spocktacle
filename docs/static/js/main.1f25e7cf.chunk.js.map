{"version":3,"sources":["Draggable.tsx","NodeComponent.tsx","LogicParser/EvaluationNode.tsx","LogicParser/Constants.js","LogicParser/Token.tsx","LogicParser/formulae/Formula.tsx","LogicParser/formulae/Not.tsx","LogicParser/formulae/Or.tsx","LogicParser/formulae/And.tsx","LogicParser/formulae/Variable.tsx","LogicParser/formulae/Parenthetical.tsx","LogicParser/formulae/Then.tsx","LogicParser/formulae/Iff.tsx","LogicParser/Pattern.tsx","LogicParser/LogicParser.tsx","SentenceInput.tsx","App.tsx","serviceWorker.js","index.tsx","App.module.scss"],"names":["Draggable","props","_React$useState","React","x","y","_React$useState2","Object","slicedToArray","position","setPosition","_React$useState3","_React$useState4","clickLocation","setClickLocation","_React$useState5","_React$useState6","isDragging","setIsDragging","newStyle","left","top","react","className","styles","draggable","width","window","innerWidth","height","style","onMouseDown","e","clientX","clientY","onMouseUp","onMouseMove","children","RED","GREEN","BLACK","NODEWIDTH","NODEHEIGHT","VERTICAL_DISTANCE","GUTTER","NodeComponent","_this","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","elementref","textWidth","setChildWidth","nodeString","setState","_ref","oldChildWidths","childWidths","objectSpread","defineProperty","updateMyWidth","_this$state","state","expanded","_this$props","node","parent","totalWidths","values","reduce","acc","child","Math","max","toString","componentDidMount","updateTextWidth","closed","leftOffsets","_i","_Object$values","length","textbox","getBBox","textContent","getColorShowingStateViolation","necessity","stateDeltasFromNecessity","getStateDelta","_i2","_Object$keys","keys","varInNecessity","stateViolations","hasOwnProperty","overallColor","futureStateViolations","getTextForNecessity","index","react_default","a","createElement","key","fill","transform","concat","ref","r","toggleExpanded","_ref2","renderNodeChildren","totalHeight","childStartingX","kids","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","n","value","nodewidth","push","x1","y1","x2","y2","stroke","strokeWidth","assertThisInitialized","err","return","_this2","_this$props2","_this$state2","necessities","myNecessityText","map","i","onClick","Component","EvaluationNode","immediateMode","arguments","mapOfVariablesToNecessitiesThatSetThem","variableThatViolatesState","join","checkIfIAmClosed","console","log","checkForStateViolation","stateDelta","respondToStateViolation","getNecessitiesThatDoNotDirectlyUpdateState","necessitiesThatDoNotDirectlyUpdateState","matchable","necessitatedStateDelta","howManyNodesWideIAm","makeNewNecAndProb","possibilities","getNecessityWithoutPossibilities","_i3","_Object$values2","toBeTrue","updateStateAndGenerateChildren","variableName","respondToFutureStateViolation","_i4","_Object$keys2","formulaToResolveForMyChildren","newNecessitiesAndProbabilitiesForChildren","formulaWithoutPossibilities","necessitiesForAllChildren","newNode","_i5","_Object$values3","necessitiesForThisChild","newChildNode","warn","FORMULA","Token","elements","syntaxmatch","evaluate","getVarName","createClass","Error","allKnownTokens","Formula","myString","toStringFunction","element","toBeFalseImplementation","toBeTrueImplementation","Not","_Formula","toBeFalse","inherits","formula","NotToken","childStateDelta","Or","notOne","wrapInNot","notTwo","formula1","formula2","OrToken","And","AndToken","Variable","notMe","Parenthetical","Then","Iff","_possibilities","firstFalseSecondTrue","wrapInAnd","firstTrueSecondFalse","_possibilities2","bothTrue","bothFalse","Pattern","classreffunction","getClassName","patterns","matches","defaultState","A","B","LogicParser","sentence","formulae","foundAMatch","cleanSentence","toUpperCase","replace","tokens","tokenizeSentence","parseTokensAndFormulae","explanation","remainingTokens","toConsumableArray","_patterns","pattern","substitutePatternInSentence","matchedPattern","matchedTokens","slice","classRepository","remainingTokensFromMatch","matchedToken","restOfSentence","token","stringToMatch","indexOf","substring","charAt","SentenceInput","_React$Component","trueref","falseref","submitSentence","stateValues","target","blur","submitSentenceNegated","onSentenceChange","onBooleansChange","trueOrFalse","newSetOfVars","split","v","newStateValues","sentences","_this$state3","trues","falses","varname","inputsection","centered","onChange","s","cols","rows","buttons","stringify","require","App","negateIt","scrollTo","root","getRoot","nodeToActuallyEvaluate","main","src_Draggable","NodeComponent_NodeComponent","SentenceInput_SentenceInput","Boolean","location","hostname","match","ReactDOM","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","module","exports","page","nodecomponent","text"],"mappings":"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","file":"static/js/main.1f25e7cf.chunk.js","sourcesContent":["import * as React from \"react\";\nimport styles from \"./App.module.scss\";\n\ninterface IProps {\n  children: React.ReactNode;\n}\n\nconst Draggable = (props: IProps) => {\n  const [position, setPosition] = React.useState({ x: 0, y: 0 });\n  const [clickLocation, setClickLocation] = React.useState({ x: 0, y: 0 });\n  const [isDragging, setIsDragging] = React.useState(false);\n\n  const startDrag = (e: React.MouseEvent) => {\n    setClickLocation({ x: e.clientX, y: e.clientY });\n    setIsDragging(true);\n  };\n  const stopDrag = () => setIsDragging(false);\n  const mouseMove = (e: React.MouseEvent) => {\n    if (isDragging) {\n      setPosition({\n        x: position.x + e.clientX - clickLocation.x,\n        y: position.y + e.clientY - clickLocation.y\n      });\n      setClickLocation({ x: e.clientX, y: e.clientY });\n    }\n  };\n\n  const newStyle = { left: position.x + \"px\", top: position.y + \"px\" };\n\n  return (\n    <svg\n      className={styles.draggable}\n      width={window.innerWidth}\n      height={5000}\n      style={newStyle}\n      onMouseDown={startDrag}\n      onMouseUp={stopDrag}\n      onMouseMove={mouseMove}\n    >\n      {props.children}\n    </svg>\n  );\n};\nexport default Draggable;\n","// TODO: REMEMBER THAT EACH NODE CENTERS ITS OWN STUFF.\n// So when there is one child, that child's X is 0!\n// The line should also go to 0!\n// It's only when we have multiple children that we need a negative number for childStartingX.\n\nimport EvaluationNode from \"LogicParser/EvaluationNode\";\nimport { IMatchable, IMatchableMap } from \"LogicParser/Token\";\nimport React from \"react\";\n// import styles from \"./App.module.scss\";\n\nexport const RED = \"red\";\nexport const GREEN = \"green\";\nexport const BLACK = \"black\";\n\ninterface INodeComponentProps {\n  x: number;\n  y: number;\n  node: EvaluationNode;\n  parent: NodeComponent | null;\n}\n\ninterface INodeComponentState {\n  leftOffsets: {\n    [key: string]: number;\n  };\n  expanded: boolean;\n  parent: NodeComponent | null;\n  childWidths: { [nodeString: string]: number };\n  closed: boolean;\n}\n\nconst NODEWIDTH = 300;\nconst NODEHEIGHT = 22;\nconst VERTICAL_DISTANCE = 60;\nconst GUTTER = 20;\n\nexport default class NodeComponent extends React.Component<\n  INodeComponentProps,\n  INodeComponentState\n> {\n  public elementref: { [key: string]: SVGTextElement | null } = {};\n  public textWidth: number = 0;\n  constructor(props: INodeComponentProps) {\n    super(props);\n    this.state = {\n      childWidths: {},\n      closed: false,\n      expanded: false,\n      leftOffsets: {},\n      parent: props.parent\n    };\n  }\n\n  public setChildWidth = (width: number, nodeString: string): void => {\n    this.setState(\n      ({ childWidths: oldChildWidths }) => ({\n        childWidths: { ...oldChildWidths, [nodeString]: width }\n      }),\n      this.updateMyWidth\n    );\n  };\n\n  public updateMyWidth = () => {\n    const { childWidths, expanded } = this.state;\n    const { node, parent } = this.props;\n\n    if (parent) {\n      if (expanded) {\n        const totalWidths = Object.values(childWidths).reduce(\n          (acc, child) => acc + child + GUTTER,\n          -GUTTER\n        );\n        parent.setChildWidth(\n          Math.max(this.textWidth, totalWidths),\n          node.toString()\n        );\n      } else {\n        parent.setChildWidth(this.textWidth, node.toString());\n      }\n    }\n  };\n\n  public componentDidMount = () => {\n    const { node } = this.props;\n    this.updateTextWidth();\n    // setTimeout(() => {\n    // node.checkIfIAmClosed();\n    this.setState({ closed: node.closed });\n    // }, 100);\n  };\n\n  public updateTextWidth = () => {\n    // Make a lookup table for the left offsets for each necessity.\n    // Since they can be of different widths,\n    // the left edge of each should be a different distance from our center.\n    const { leftOffsets } = this.state;\n    this.textWidth = 0;\n    for (const textbox of Object.values(this.elementref)) {\n      const width = (textbox as SVGTextElement).getBBox().width;\n      leftOffsets[(textbox as SVGTextElement).textContent as string] =\n        -width / 2;\n      if (width > this.textWidth) {\n        this.textWidth = width;\n      }\n    }\n\n    this.setState(\n      {\n        leftOffsets\n      },\n      this.updateMyWidth\n    );\n  };\n\n  public getColorShowingStateViolation = (necessity: IMatchable): string => {\n    // A necessity may mandate a change to state.\n    // For example, if a necessity is that \"!A\" is true,\n    // then this necessity places a strict requirement upon our state:\n    // {A: false}\n    //\n    // We'll call these stateDeltas,\n    // taking the form of IStateDelta (a simple map of string to boolean),\n    // and each node can return them them via getStateDelta().\n    const stateDeltasFromNecessity = necessity.getStateDelta();\n    if (stateDeltasFromNecessity === null) {\n      return BLACK;\n    }\n\n    const { node } = this.props;\n    for (const varInNecessity of Object.keys(stateDeltasFromNecessity)) {\n      // Let's see if that variable is flagged as a violation in our node.\n      if (node.stateViolations.hasOwnProperty(varInNecessity)) {\n        // overallColor is what determines the color\n        // we should use when drawing the line\n        // to this node\n        node.overallColor = RED;\n        return RED;\n      }\n\n      if (node.futureStateViolations.hasOwnProperty(varInNecessity)) {\n        if (node.overallColor === BLACK) {\n          node.overallColor = GREEN;\n        }\n        return GREEN;\n      }\n    }\n    return BLACK;\n  };\n\n  public getTextForNecessity = (necessity: IMatchable, index: number) => {\n    const { leftOffsets } = this.state;\n\n    return (\n      <text\n        key={necessity.toString()}\n        fill={this.getColorShowingStateViolation(necessity)}\n        transform={`translate(${leftOffsets[necessity.toString()] ||\n          0} ${index * NODEHEIGHT})`}\n        ref={r => (this.elementref[necessity.toString()] = r)}\n      >\n        {necessity.toString()}\n      </text>\n    );\n  };\n\n  public toggleExpanded = () => {\n    this.setState(\n      ({ expanded }) => ({ expanded: !expanded }),\n      this.updateMyWidth\n    );\n  };\n\n  public render() {\n    const { node, x, y } = this.props;\n    const { expanded, closed } = this.state;\n\n    const necessities: IMatchableMap = node.necessities;\n    const totalHeight: number = Object.keys(necessities).length * NODEHEIGHT;\n    const myNecessityText = Object.values(necessities).map((n, i) =>\n      this.getTextForNecessity(n as IMatchable, i)\n    );\n\n    const { childWidths } = this.state;\n\n    return (\n      <g transform={`translate(${x} ${y})`} className=\"node\">\n        <rect\n          x={-5}\n          y={totalHeight - 10}\n          width={10}\n          height={10}\n          style={{ stroke: \"black\", fill: closed ? \"black\" : \"white\" }}\n        />\n        {myNecessityText}\n        {node.children.length > 0 && (\n          <text y={totalHeight + 18} x=\"-5\" onClick={this.toggleExpanded}>\n            +\n          </text>\n        )}\n        {expanded &&\n          this.renderNodeChildren(totalHeight + 21, node, childWidths)}\n      </g>\n    );\n  }\n\n  public renderNodeChildren = (\n    totalHeight: number,\n    node: EvaluationNode,\n    childWidths: { [x: string]: number }\n  ) => {\n    const totalRowWidth = Object.values(childWidths).reduce(\n      (acc, child) => acc + child + GUTTER,\n      -GUTTER\n    );\n    let childStartingX = -totalRowWidth * 0.5;\n\n    const kids: React.ReactElement[] = [];\n    for (const n of node.children) {\n      // Before we place the component, because every component is centered,\n      // we don't want its left edge too far left.\n      // Add half the component's width,\n      // so that its left edge will be aligned with the leftmost point.\n      const nodewidth = childWidths[n.toString()] || NODEWIDTH;\n\n      childStartingX += nodewidth / 2;\n\n      kids.push(\n        <g key={n.toString()}>\n          <line\n            x1=\"0\"\n            y1={totalHeight + 3}\n            x2={childStartingX}\n            y2={totalHeight + VERTICAL_DISTANCE - NODEHEIGHT}\n            style={{\n              stroke: n.overallColor,\n              strokeWidth: 2\n            }}\n          />\n          {\n            <NodeComponent\n              x={childStartingX}\n              y={totalHeight + VERTICAL_DISTANCE}\n              node={n}\n              parent={this}\n            />\n          }\n        </g>\n      );\n      // And after we place the component, because every component is centered,\n      // we want the start of the next component's left edge to be at our right edge.\n      // So add half the component's width,\n      // and a little bit of gutter.\n\n      childStartingX += nodewidth / 2;\n      childStartingX += GUTTER;\n    }\n    return kids;\n  };\n}\n","import { INecessitiesAndPossibilities, IStateDelta } from \"App\";\nimport { BLACK, GREEN, RED } from \"NodeComponent\";\nimport { IMatchable, IMatchableMap, IStateInterface } from \"./Token\";\n\ninterface IHashMapOfVariablesToNecessities {\n  [varname: string]: IMatchable;\n}\n\nexport default class EvaluationNode {\n  public mapOfVariablesToNecessitiesThatSetThem: IHashMapOfVariablesToNecessities = {};\n  public readonly state: IStateInterface;\n  public children: EvaluationNode[];\n  public variableThatViolatesState?: string;\n  public futureStateViolations: IStateDelta = {};\n  public stateViolations: IStateDelta = {};\n  public overallColor = BLACK;\n  public closed: boolean = false;\n  constructor(\n    public necessities: IMatchableMap,\n    state: IStateInterface,\n    public parent?: EvaluationNode,\n    public immediateMode: boolean = true\n  ) {\n    this.children = [];\n    this.state = { ...state };\n    if (immediateMode) {\n      console.log(\"About to updatestate\");\n      this.updateStateAndGenerateChildren();\n    }\n  }\n\n  public toString = () => Object.keys(this.necessities).join();\n\n  public respondToStateViolation(variableName: string) {\n    console.log(\"STATE VIOLATION FOR variableName \", variableName);\n    this.stateViolations[variableName] = true;\n    this.overallColor = RED;\n    this.closed = true;\n    this.checkIfIAmClosed();\n    // Tell our parent that one of their state requirements\n    // will be violated by a descendent.\n    // (This way, they can highlight it so that the user can see where the problem started.)\n    if (this.parent) {\n      this.parent.respondToFutureStateViolation(variableName);\n    }\n  }\n\n  public checkIfIAmClosed = () => {\n    // Now let's see if our node is closed.\n    if (this.toString() === \"(A||!C),!A\") {\n      console.log(\"In checkIfIAmClosed for node \", this.toString());\n      console.log(\"this.children is \", this.children);\n      console.log(\"this.parent is \", this.parent);\n    }\n    if (this.children.length > 0) {\n      if (this.toString() === \"(A||!C),!A\") {\n        console.log(\"I do have children \");\n      }\n      this.closed = true;\n      for (const child of this.children) {\n        if (this.toString() === \"(A||!C),!A\") {\n          console.log(\"child.closed is \", child.closed);\n        }\n        if (!child.closed) {\n          console.log(\"NOT CLOSED: \" + this.toString());\n          console.log(\"Because child \" + child.toString() + \" isn't closed\");\n          this.closed = false;\n          break;\n        }\n      }\n    }\n    if (this.parent) {\n      if (this.toString() === \"(!Q->(R&&!S)),(P||Q),P&&!!Q\") {\n        console.log(\n          \"(!Q->(R&&!S)),(P||Q),P&&!!Q is asking my parent if it is closed\"\n        );\n      }\n      this.parent.checkIfIAmClosed();\n    }\n  };\n\n  public respondToFutureStateViolation(variableName: string) {\n    console.log(\"FUTURE STATE VIOLATION FOR variableName \", variableName);\n    if (this.toString() === \"(P<->!!Q)&&(!Q->(R&&!S)),(S->(P||Q)),(S&&Q),!P\") {\n      console.log(\"respondToFutureStateViolation for node \", this.toString());\n      console.log(\"this.children is \", this.children);\n    }\n    this.futureStateViolations[variableName] = true;\n    this.overallColor = GREEN;\n    this.checkIfIAmClosed();\n    if (this.parent) {\n      this.parent.respondToFutureStateViolation(variableName);\n    }\n  }\n\n  public checkForStateViolation = (stateDelta: IStateDelta): string | null => {\n    for (const key of Object.keys(stateDelta)) {\n      if (this.state.hasOwnProperty(key)) {\n        if (stateDelta[key] !== this.state[key]) {\n          this.respondToStateViolation(key);\n          return key;\n        }\n      } else {\n        // Our current state doesn't know or care about this variable.\n        // But we should now set it so that it DOES.\n        this.state[key] = stateDelta[key];\n      }\n    }\n    this.checkIfIAmClosed();\n    return null;\n  };\n\n  public rememberWhichNecessitySetWhichVariables(\n    stateDelta: IStateDelta,\n    necessity: IMatchable\n  ) {\n    for (const key of Object.keys(stateDelta)) {\n      this.mapOfVariablesToNecessitiesThatSetThem[key] = necessity;\n    }\n  }\n\n  public getNecessitiesThatDoNotDirectlyUpdateState = (): IMatchableMap => {\n    const necessitiesThatDoNotDirectlyUpdateState: IMatchableMap = {};\n    for (const matchable of Object.values(this.necessities)) {\n      const necessitatedStateDelta: IStateDelta | null = (matchable as IMatchable).getStateDelta();\n      if (necessitatedStateDelta !== null) {\n        console.log(\"Found a state delta: \", necessitatedStateDelta);\n        const variableThatViolatesState = this.checkForStateViolation(\n          necessitatedStateDelta\n        );\n        if (variableThatViolatesState) {\n          this.variableThatViolatesState = variableThatViolatesState;\n          return {};\n        }\n      } else {\n        necessitiesThatDoNotDirectlyUpdateState[\n          matchable.toString()\n        ] = matchable;\n      }\n    }\n    return necessitiesThatDoNotDirectlyUpdateState;\n  };\n\n  public updateStateAndGenerateChildren() {\n    // Necessities that update state directly are\n    // different from those that don't, in fundamental ways.\n    // We want to use them to update our state,\n    // while checking to see if they violate EXISTING state.\n    //\n    // And we don't want to pass them down to our children as necessities,\n    // since after all, they're really embodied in the state we'll pass on.\n    //\n\n    const necessitiesThatDoNotDirectlyUpdateState = this.getNecessitiesThatDoNotDirectlyUpdateState();\n    if (\n      Object.keys(necessitiesThatDoNotDirectlyUpdateState).length ===\n      Object.keys(this.necessities).length\n    ) {\n      console.log(\"NO STATE DELTAS THERE\");\n    }\n\n    if (Object.keys(necessitiesThatDoNotDirectlyUpdateState).length === 0) {\n      console.warn(\n        \"There are no more necessities left to prove and this.variableThatViolatesState is \" +\n          this.variableThatViolatesState\n      );\n      return;\n    }\n\n    // Now I want to pick a necessity to break down into ITS necessities and probabilities.\n    // Ideally, one without any probabilities would be best!\n\n    let formulaToResolveForMyChildren: IMatchable;\n\n    // First see if there's a nice, simple one that gives us only necessities.\n    // Since possibilities require us to make multiple branches, each with a child,\n    // it's easiest to deal with necessity-only formulae first.\n\n    const formulaWithoutPossibilities = this.getNecessityWithoutPossibilities(\n      necessitiesThatDoNotDirectlyUpdateState\n    );\n\n    if (formulaWithoutPossibilities !== null) {\n      formulaToResolveForMyChildren = formulaWithoutPossibilities;\n      console.log(\n        \"Found a formulaWithoutPossibilities! It's \",\n        formulaWithoutPossibilities\n      );\n    } else {\n      formulaToResolveForMyChildren = Object.values(\n        necessitiesThatDoNotDirectlyUpdateState\n      )[0] as IMatchable;\n    }\n\n    // Whichever formula we plucked,\n    // delete it from the payload we're passing on,\n    // because we're going to break it down into its OWN necessities and probabilities\n    // and use those to generate new sets of necessities for each of our children\n    //\n    delete necessitiesThatDoNotDirectlyUpdateState[\n      formulaToResolveForMyChildren.toString()\n    ];\n\n    let newNecessitiesAndProbabilitiesForChildren: INecessitiesAndPossibilities;\n\n    newNecessitiesAndProbabilitiesForChildren = formulaToResolveForMyChildren.toBeTrue();\n\n    console.log(\n      \"newNecessitiesAndProbabilitiesForChildren are \",\n      newNecessitiesAndProbabilitiesForChildren\n    );\n\n    console.log(\n      \"necessitiesThatDoNotDirectlyUpdateState are \",\n      necessitiesThatDoNotDirectlyUpdateState\n    );\n\n    // Now combine the necessities we already had\n    // with the ones we got from that child\n    const necessitiesForAllChildren = {\n      ...necessitiesThatDoNotDirectlyUpdateState,\n      ...newNecessitiesAndProbabilitiesForChildren.necessities\n    };\n\n    console.log(\"necessitiesForAllChildren are \", necessitiesForAllChildren);\n    // If there are no possibilities, then we only need one kid\n    if (\n      Object.keys(newNecessitiesAndProbabilitiesForChildren.possibilities)\n        .length === 0\n    ) {\n      console.log(\"We only need one kid\");\n      const newNode = new EvaluationNode(\n        necessitiesForAllChildren,\n        { ...this.state },\n        this,\n        false\n      );\n      this.children = [newNode];\n      newNode.updateStateAndGenerateChildren();\n    } else {\n      // Because there are possibilities, we need multiple children.\n      // Our tableau must branch.\n      // So cycle through our possibilities,\n      // and give each one to a child\n      // (by adding it to the mandatory necessities, and then passing that set to a new child as its necessities)\n      this.children = [];\n\n      for (const matchable of Object.values(\n        newNecessitiesAndProbabilitiesForChildren.possibilities\n      )) {\n        const necessitiesForThisChild = {\n          ...necessitiesForAllChildren,\n          [matchable.toString()]: matchable\n        };\n        console.log(\"Making a new EvaluationNode with state \", {\n          ...this.state\n        });\n\n        const newChildNode = new EvaluationNode(\n          necessitiesForThisChild,\n          { ...this.state },\n          this,\n          false\n        );\n        this.children.push(newChildNode);\n        newChildNode.updateStateAndGenerateChildren();\n      }\n    }\n  }\n\n  public howManyNodesWideIAm = (): number => {\n    if (this.children.length === 0) {\n      return 1;\n    }\n    return this.children.reduce(\n      (acc, child) => acc + child.howManyNodesWideIAm(),\n      0\n    );\n  };\n\n  public makeNewNecAndProb = (\n    necessities: IMatchableMap,\n    possibilities: IMatchableMap\n  ): INecessitiesAndPossibilities => ({\n    necessities,\n    possibilities\n  });\n\n  public getNecessityWithoutPossibilities = (\n    necessitiesThatDoNotDirectlyUpdateState: IMatchableMap\n  ): IMatchable | null => {\n    for (const matchable of Object.values(\n      necessitiesThatDoNotDirectlyUpdateState\n    )) {\n      if (\n        Object.keys((matchable as IMatchable).toBeTrue().possibilities)\n          .length === 0\n      ) {\n        return matchable as IMatchable;\n      }\n    }\n    return null;\n  };\n}\n\n/*\n\nMay 23, ride to work\n\nRealize that I should be memoizing my toBeFalse and toBeTrue results for each Formula.\nThis was a good part of having a toBeFalse() and toBeTrue() parent class method\nthat calls the implementation-specific toBeFalseImplementation and toBeTrueImplementation\n\nUnfortunately, that creates a problem!\n\nIf your toBeFalse() list of Formulae (necessities and probabilities) is now\none of your properties,\nIt's possible that one of the Formulae contained in there is, well, you.\n\nAnd stringify will barf on the circular reference.\n\nIt's Variable that's the culprit! A lot of \"this\" in its necessities...\n\nMay 22, ride home\n\nDid parentheses, Then, and Iff. Started creating EvaluationNode.\n\nDiscovered that I had the wrong syntaxmatch for And and Then nodes -- should present themselves\nas FORMULA, but they were still persisting in thinking of themselves as BINARYOPERATORS.\n\n\n\n\n\n\n\n\n\n\n\n\n\nMay 22, noon\n\nSo I've gotten to the point where I can get the necessities and possibilities for anything to be true.\n\nTODO: Implement and test parentheses!\n\nTODO: Implement and test Then.\n\nTODO: Implement and test Iff.\n\nTODO: Get this going with the rules for the material conditional (if->then)!\n\nTODO: Also do material equivalence! ≡ or iff!\n\nNote that in the case of ≡ (iff) you'll have two possibilities,\neach of which will have multiple necessities!\n\nTo handle this: create wrapInAnd(), so that I can mandate the truth of them.\n\nSo A≡B creates two possibilities:\n\nA AND B         !A AND !B\n\neach of which will yield necessities:\n\nA, B                !A, !B\n\nAnd then, when I cycle through necessities, I will catch the proposed state changes.\n\n\n\nCYCLING THROUGH NECESSITIES\n\nWhenever I ask a formulae to give me the sentence(s) that will make it true,\nthere is the possibility that the sentence(s) will entail the definition of a variable in my state.\n\nFor example, if a sentence(s) requires that \"!A\" is true,\nthen I know I must setState({A:false}).\n\nSo what's good about this is that:\n\nI can always just cycle through my necessities,\ncall getDeltaState() on each one,\nand if I get a non-null response,\nI know I can apply it to my current state to get my next state!\n\n(The one I'll pass on to my branches.)\n\nAnd when \"applying\" those deltaStates to my current state,\nI will check for conflicts.\n\nThat will allow me to flag any necessity that violates my state's definitions!\n\n\nHOW THESE GET USED TO DO PROOFS.\n\nSo I guess I need an EvaluationNode.\nIt receives an initial state and an array of necessities.\n\n(Of course, to find contradictions, my very FIRST EvaluationNode should receive one sentence wrapped in a NOT!)\n\nSo if my sentence is A->B, what my first EvaluationNode will get is [!(A->B)],\n\nand toBeTrue() on that will give me A->B.toBeFalse(),\n\nwhich will give me the two necessities:\n\nA and !B.\n\nThe EvaluationNode is the class that receives a state and an array of necessities,\ncalls getDeltaState() on all those necessities (to update state and detect contradictions),\npops off the first necessity,\ncalls toBeTrue() on it to get MORE necessities and possibilities,\nand then, if all is good,\n\n1. No possibilities. Creates a new EvaluationNode with the old necessities array (minus that popped-first-one)\n+ the new necessities that the popped-first-one created.\n\n2. Possibilities. Pop them, and for each, make a new necessities array by adding that \"possibility\" to a clone of\nour old necessities array (minus that popped-first-one). Then make a new EvaluationNode with that array.\n\nAlways, when making a child node, pass down a clone of your current state.\n\n\n\n\nONE IMPORTANT NOTE ON CYCLING THROUGH NECESSITIES:\n\nI should first filter them by whether or not getDeltaState() returns anything useful!\nBecause those I can act on immediately, put them in my state, and don't pass them on.\n\nSecondarily, I should sort them so that the ones without possibilities are first.\n\nOK, so each EvaluationNode really doesn't \"cycle through\" necessities.\n\nIt DOES cycle through all the ones that yield a real getDeltaState(), so it can remove them.\n\nThen it pops off the first necessity and gets ITS toBeTrue() data.\n\n\n\nThe EvaluationNodes' ctor should receive a flag telling it if we're in immediateMode or not.\n\nIf so, call evaluate() once you're made.\n\nIf not, then wait for a GUI action to call evaluate() on you.\n\n\n\n\nMay 22, AM\n\nI'll put a getStateDelta() function on Formula, and it'll default to returning an empty set.\n\nVery simple!\n\nExcept, what if I'm asking an AND what its necessities are to be true?\n\nI guess it returns its element 0 and element 2.\n\nWhat about toBeFalse?\n\nIts possibilities are... a new NOT Formula wrapped around element 0, and a new NOT Formula wrapped around element 2?\n\nOK... this works, at least. We're not descending through a series of toBeFalse() calls and toBeTrue() calls.\n\nAnd my getStateDelta() implementation on NOT will allow me to recognize when it's asking for a stateDelta!\n\nSo here's an interesting dilemma.\n\n.toBeFalse() means \"Give me the formula that would be true if this sentence were false.\"\n\n*/\n","export const OPENPARENS = \"OPENPARENS\";\nexport const CLOSEPARENS = \"CLOSEPARENS\";\nexport const VARIABLE = \"VARIABLE\";\nexport const BINARYOPERATOR = \"BINARYOPERATOR\";\nexport const UNARYOPERATOR = \"UNARYOPERATOR\";\nexport const FORMULA = \"FORMULA\";\nexport const NOT = \"NOT\";\n","import {\n  IJSONofIMatchable,\n  INecessitiesAndPossibilities,\n  IStateDelta\n} from \"App\";\nimport {\n  BINARYOPERATOR,\n  CLOSEPARENS,\n  OPENPARENS,\n  UNARYOPERATOR\n} from \"./Constants\";\n\nexport interface IMatchable {\n  className: string;\n  elements: string | IMatchable[];\n  syntaxmatch: string;\n  toString(): string;\n  getVarName(): string | null;\n  evaluate(state: object): boolean;\n  toBeFalse(): INecessitiesAndPossibilities;\n  toBeTrue(): INecessitiesAndPossibilities;\n  getStateDelta(): IStateDelta | null;\n}\n\nexport interface IMatchableMap {\n  [key: string]: IMatchable | IJSONofIMatchable;\n}\n\nexport type MatchableArgs = [IMatchable[], string, any];\n\nexport interface IStateInterface {\n  [key: string]: boolean;\n}\n\nexport class Token implements IMatchable {\n  public elements: string;\n  public syntaxmatch: string;\n  public className: any;\n  constructor(elements: string, syntaxmatch: string, className: any) {\n    this.elements = elements;\n    this.syntaxmatch = syntaxmatch;\n    this.className = className;\n  }\n\n  public evaluate = (state: IStateInterface) => false;\n\n  public getVarName = (): string | null => {\n    return this.elements;\n  };\n\n  public toString = (): string => {\n    return this.elements;\n  };\n\n  public toBeFalse(): INecessitiesAndPossibilities {\n    throw new Error(\"We're in the non-overridden toBeFalseFunc\");\n  }\n\n  public toBeTrue(): INecessitiesAndPossibilities {\n    throw new Error(\"We're in the non-overridden toBeTrueFunc\");\n  }\n\n  public getStateDelta() {\n    return null;\n  }\n}\n\nexport const allKnownTokens: Token[] = [\n  new Token(\"->\", BINARYOPERATOR, \"Then\"),\n  new Token(\"<->\", BINARYOPERATOR, \"Iff\"),\n  new Token(\"(\", OPENPARENS, \"Formula\"),\n  new Token(\")\", CLOSEPARENS, \"Formula\"),\n  new Token(\"!\", UNARYOPERATOR, \"Not\"),\n  new Token(\"AND\", BINARYOPERATOR, \"And\"),\n  new Token(\"&&\", BINARYOPERATOR, \"And\"),\n  new Token(\"OR\", BINARYOPERATOR, \"Or\"),\n  new Token(\"||\", BINARYOPERATOR, \"Or\")\n];\n","import { INecessitiesAndPossibilities, IStateDelta } from \"App\";\nimport { IMatchable, IStateInterface } from \"../Token\";\n\nexport class Formula implements IMatchable {\n  public elements: IMatchable[];\n  public syntaxmatch: string;\n  public className: any;\n  public myString?: string;\n  constructor(elements: IMatchable[], syntaxmatch: string, className: string) {\n    this.elements = elements;\n    this.syntaxmatch = syntaxmatch;\n    this.className = className;\n  }\n\n  public evaluate = (state: IStateInterface): boolean => {\n    return true;\n  };\n\n  public getVarName = (): string | null => {\n    return null;\n  };\n\n  public toStringFunction = (): string => {\n    return this.elements.reduce(\n      (acc: string, element) => acc + element.toString(),\n      \"\"\n    );\n  };\n\n  public toBeFalse(): INecessitiesAndPossibilities {\n    return this.toBeFalseImplementation();\n  }\n\n  public toBeFalseImplementation(): INecessitiesAndPossibilities {\n    throw new Error(\"We're in the non-overridden toBeFalseFunc\");\n  }\n\n  public toBeTrue(): INecessitiesAndPossibilities {\n    return this.toBeTrueImplementation();\n  }\n\n  public toBeTrueImplementation(): INecessitiesAndPossibilities {\n    throw new Error(\"We're in the non-overridden toBeFalseFunc\");\n  }\n\n  public getStateDelta(): IStateDelta | null {\n    return null;\n  }\n\n  public toString = (): string => {\n    // We'll memoize our string\n    if (!this.myString) {\n      this.myString = this.toStringFunction();\n    }\n    return this.myString;\n  };\n}\n","import { INecessitiesAndPossibilities, IStateDelta } from \"App\";\nimport { FORMULA, UNARYOPERATOR } from \"../Constants\";\nimport { IMatchable, IStateInterface, Token } from \"../Token\";\nimport { Formula } from \"./Formula\";\n\nexport class Not extends Formula {\n  public static NotToken = new Token(\"!\", UNARYOPERATOR, \"Not\");\n  public static wrapInNot(formula: IMatchable): Not {\n    // Here's the funny thing:\n    // if we're wrapping a Not object in another Not,\n    // we should really just return that Not object's content, no?\n    // Well, for now, let it lie.\n    return new Not([Not.NotToken, formula], FORMULA, \"Not\");\n  }\n  constructor(elements: IMatchable[], syntaxmatch: string, className: string) {\n    super(elements, FORMULA, \"Not\");\n  }\n  public toBeFalseImplementation = (): INecessitiesAndPossibilities => {\n    return (this.elements[1] as IMatchable).toBeTrue();\n  };\n\n  public evaluate = (state: IStateInterface): boolean => {\n    return !(this.elements[1] as IMatchable).evaluate(state);\n  };\n\n  public toBeTrueImplementation = (): INecessitiesAndPossibilities => {\n    return (this.elements[1] as IMatchable).toBeFalse();\n  };\n\n  public getStateDelta(): IStateDelta | null {\n    const childStateDelta = (this.elements[1] as IMatchable).getStateDelta();\n\n    if (childStateDelta) {\n      for (const key of Object.keys(childStateDelta)) {\n        childStateDelta[key] = !childStateDelta[key];\n      }\n    }\n    return childStateDelta;\n  }\n}\n","import { INecessitiesAndPossibilities } from \"App\";\nimport { BINARYOPERATOR, FORMULA } from \"../Constants\";\nimport { IMatchable, IMatchableMap, IStateInterface, Token } from \"../Token\";\nimport { Formula } from \"./Formula\";\nimport { Not } from \"./Not\";\n\nexport class Or extends Formula {\n  public static OrToken = new Token(\"||\", BINARYOPERATOR, \"Or\");\n  public static wrapInOr(formula1: IMatchable, formula2: IMatchable): Or {\n    return new Or([formula1, Or.OrToken, formula2], FORMULA, \"Or\");\n  }\n  constructor(elements: IMatchable[], syntaxmatch: string, className: string) {\n    super(elements, FORMULA, \"Or\");\n  }\n\n  public evaluate = (state: IStateInterface): boolean => {\n    return (\n      (this.elements[0] as IMatchable).evaluate(state) ||\n      (this.elements[2] as IMatchable).evaluate(state)\n    );\n  };\n\n  public toBeFalseImplementation = (): INecessitiesAndPossibilities => {\n    const necessities: IMatchableMap = {};\n\n    const notOne = Not.wrapInNot(this.elements[0] as IMatchable);\n    const notTwo = Not.wrapInNot(this.elements[2] as IMatchable);\n    necessities[notOne.toString()] = notOne;\n    necessities[notTwo.toString()] = notTwo;\n\n    return {\n      necessities,\n      possibilities: {}\n    };\n  };\n\n  public toBeTrueImplementation = (): INecessitiesAndPossibilities => {\n    const possibilities: IMatchableMap = {};\n\n    possibilities[this.elements[0].toString()] = this.elements[0] as IMatchable;\n    possibilities[this.elements[2].toString()] = this.elements[2] as IMatchable;\n\n    return {\n      necessities: {},\n      possibilities\n    };\n  };\n}\n","import { INecessitiesAndPossibilities } from \"App\";\nimport { BINARYOPERATOR, FORMULA } from \"../Constants\";\nimport { IMatchable, IMatchableMap, IStateInterface, Token } from \"../Token\";\nimport { Formula } from \"./Formula\";\nimport { Not } from \"./Not\";\n\nexport class And extends Formula {\n  public static AndToken = new Token(\"&&\", BINARYOPERATOR, \"And\");\n  public static wrapInAnd(formula1: IMatchable, formula2: IMatchable): And {\n    return new And([formula1, And.AndToken, formula2], FORMULA, \"And\");\n  }\n  constructor(elements: IMatchable[], syntaxmatch: string, className: string) {\n    super(elements, FORMULA, \"And\");\n  }\n\n  public evaluate = (state: IStateInterface): boolean => {\n    return (\n      (this.elements[0] as IMatchable).evaluate(state) &&\n      (this.elements[2] as IMatchable).evaluate(state)\n    );\n  };\n\n  public toBeFalseImplementation = (): INecessitiesAndPossibilities => {\n    const possibilities: IMatchableMap = {};\n\n    const notOne = Not.wrapInNot(this.elements[0] as IMatchable);\n    const notTwo = Not.wrapInNot(this.elements[2] as IMatchable);\n    possibilities[notOne.toString()] = notOne;\n    possibilities[notTwo.toString()] = notTwo;\n\n    return {\n      necessities: {},\n      possibilities\n    };\n  };\n\n  public toBeTrueImplementation = (): INecessitiesAndPossibilities => {\n    const necessities: IMatchableMap = {};\n\n    necessities[this.elements[0].toString()] = this.elements[0] as IMatchable;\n    necessities[this.elements[2].toString()] = this.elements[2] as IMatchable;\n\n    return {\n      necessities,\n      possibilities: {}\n    };\n  };\n}\n","import { INecessitiesAndPossibilities, IStateDelta } from \"App\";\nimport { IMatchable, IStateInterface, Token } from \"../Token\";\nimport { Formula } from \"./Formula\";\nimport { Not } from \"./Not\";\n\nexport class Variable extends Formula {\n  constructor(elements: IMatchable[], syntaxmatch: string, className: string) {\n    super(elements, syntaxmatch, \"Variable\");\n  }\n\n  public getVarName = () => {\n    return (this.elements[0] as Token).getVarName();\n  };\n\n  public toBeFalseImplementation = (): INecessitiesAndPossibilities => {\n    const notMe = Not.wrapInNot(this);\n    return { necessities: { [notMe.toString()]: notMe }, possibilities: {} };\n  };\n\n  public toBeTrueImplementation = (): INecessitiesAndPossibilities => {\n    return { necessities: { [this.toString()]: this }, possibilities: {} };\n  };\n\n  public evaluate = (state: IStateInterface): boolean => {\n    return state[this.elements[0].toString()];\n  };\n\n  public getStateDelta(): IStateDelta {\n    return { [this.elements[0].toString()]: true };\n  }\n}\n","import { INecessitiesAndPossibilities, IStateDelta } from \"App\";\nimport { IMatchable, IStateInterface } from \"../Token\";\nimport { Formula } from \"./Formula\";\n\nexport class Parenthetical extends Formula {\n  constructor(elements: IMatchable[], syntaxmatch: string, className: string) {\n    super(elements, syntaxmatch, \"Formula\");\n  }\n\n  public evaluate = (state: IStateInterface): boolean => {\n    return (this.elements[1] as IMatchable).evaluate(state);\n  };\n\n  public getVarName = (): string | null => {\n    return (this.elements[1] as IMatchable).getVarName();\n  };\n\n  public toStringFunction = (): string => {\n    return \"(\" + this.elements[1].toString() + \")\";\n  };\n\n  public toBeFalseImplementation(): INecessitiesAndPossibilities {\n    return (this.elements[1] as IMatchable).toBeFalse();\n  }\n\n  public toBeTrueImplementation(): INecessitiesAndPossibilities {\n    return (this.elements[1] as IMatchable).toBeTrue();\n  }\n\n  public getStateDelta(): IStateDelta | null {\n    return (this.elements[1] as IMatchable).getStateDelta();\n  }\n}\n","import { INecessitiesAndPossibilities } from \"App\";\nimport { FORMULA } from \"../Constants\";\nimport { IMatchable, IMatchableMap, IStateInterface } from \"../Token\";\nimport { Formula } from \"./Formula\";\nimport { Not } from \"./Not\";\n\nexport class Then extends Formula {\n  constructor(elements: IMatchable[], syntaxmatch: string, className: string) {\n    super(elements, FORMULA, \"Then\");\n  }\n\n  public evaluate = (state: IStateInterface): boolean => {\n    return (\n      !(this.elements[0] as IMatchable).evaluate(state) ||\n      (this.elements[2] as IMatchable).evaluate(state)\n    );\n  };\n\n  public toBeFalseImplementation = (): INecessitiesAndPossibilities => {\n    // For an if->then to be false,\n    // the antecedent must be true and the consequent must be false.\n    const necessities: IMatchableMap = {};\n    necessities[this.elements[0].toString()] = this.elements[0] as IMatchable;\n    const notTwo = Not.wrapInNot(this.elements[2] as IMatchable);\n    necessities[notTwo.toString()] = notTwo;\n\n    return {\n      necessities,\n      possibilities: {}\n    };\n  };\n\n  public toBeTrueImplementation = (): INecessitiesAndPossibilities => {\n    // For an if->then to be false,\n    // EITHER the antecedent must be false OR the consequent must be true.\n    const possibilities: IMatchableMap = {};\n    const notOne = Not.wrapInNot(this.elements[0] as IMatchable);\n    possibilities[notOne.toString()] = notOne;\n    possibilities[this.elements[2].toString()] = this.elements[2] as IMatchable;\n\n    return {\n      necessities: {},\n      possibilities\n    };\n  };\n}\n","import { INecessitiesAndPossibilities } from \"App\";\nimport { FORMULA } from \"../Constants\";\nimport { IMatchable, IStateInterface } from \"../Token\";\nimport { And } from \"./And\";\nimport { Formula } from \"./Formula\";\nimport { Not } from \"./Not\";\n\nexport class Iff extends Formula {\n  constructor(elements: IMatchable[], syntaxmatch: string, className: string) {\n    super(elements, FORMULA, \"Iff\");\n  }\n\n  public evaluate = (state: IStateInterface): boolean => {\n    return (\n      (this.elements[0] as IMatchable).evaluate(state) ===\n      (this.elements[2] as IMatchable).evaluate(state)\n    );\n  };\n\n  public toBeFalseImplementation = (): INecessitiesAndPossibilities => {\n    // For an iff A<->B to be false,\n    // there are two possibilities:\n    // either the antecedent is true and the consequent is false\n    // OR the antecedent is false and the consequent is true\n    const firstFalseSecondTrue = And.wrapInAnd(\n      Not.wrapInNot(this.elements[0] as IMatchable),\n      this.elements[2] as IMatchable\n    );\n\n    const firstTrueSecondFalse = And.wrapInAnd(\n      this.elements[0] as IMatchable,\n      Not.wrapInNot(this.elements[2] as IMatchable)\n    );\n    return {\n      necessities: {},\n      possibilities: {\n        [firstFalseSecondTrue.toString()]: firstFalseSecondTrue,\n        [firstTrueSecondFalse.toString()]: firstTrueSecondFalse\n      }\n    };\n  };\n\n  public toBeTrueImplementation = (): INecessitiesAndPossibilities => {\n    // For an iff A<->B to be true,\n    // there are two possibilities:\n    // either the antecedent and consequent are both false\n    // OR they are both true.\n    const bothTrue = And.wrapInAnd(\n      this.elements[0] as IMatchable,\n      this.elements[2] as IMatchable\n    );\n\n    const bothFalse = And.wrapInAnd(\n      Not.wrapInNot(this.elements[0] as IMatchable),\n      Not.wrapInNot(this.elements[2] as IMatchable)\n    );\n\n    return {\n      necessities: {},\n      possibilities: {\n        [bothTrue.toString()]: bothTrue,\n        [bothFalse.toString()]: bothFalse\n      }\n    };\n  };\n}\n","import { IMatchable } from \"./Token\";\n\nexport default class Pattern {\n  constructor(\n    public elements: string[],\n    public syntaxmatch: string,\n    public classreffunction: any\n  ) {}\n\n  public getClassName = (elements: IMatchable[]): string => {\n    return this.classreffunction(elements);\n  };\n}\n","import { IStateDelta } from \"App\";\nimport * as classRepository from \"./classRepository\";\nimport {\n  BINARYOPERATOR,\n  CLOSEPARENS,\n  FORMULA,\n  OPENPARENS,\n  UNARYOPERATOR,\n  VARIABLE\n} from \"./Constants\";\nimport { Variable } from \"./formulae/Variable\";\nimport Pattern from \"./Pattern\";\nimport { allKnownTokens, IMatchable, Token } from \"./Token\";\n\n// TODO: \"And\" has an interesting thing with toBeFalse().\n// I need to be careful, because elements[0] might set up a stateDelta.\n// And so might elements 2.\n\n// TODO: Pattern is NOT THE SAME AS A TOKEN!\n// It doesn't extend Token, and it doesn't need to!\n\n// Give it different CTOR arguments,\n// and give it a getClassName method instead of a classref property.\n\n// Yes, that getClassName method will *return* a classref,\n// but it'll (usually) extract it from the matchedTokens.\n\n// TODO: Negation is too big to do in a single recursive pass.\n// I really need two things.\n// 1. When negating a Formula, what do I get back?\n// A scope object for the variables in that Formula?\n// Or, sometimes, NOT that. Sometimes I get a new Formula.\n// In negating !(A -> B) I would get (A -> B).\n\n// TODO: Shortcut when negating a UNARYOPERATOR Formula!\n// If it's a negation operator, just return elements[0]!\n\n// It's in the last pass of negating a specific Formula\n// that we would see if it is *capable* of setting variables in scope.\n\n// negating !A would obviously set { A: true }.\n// Why? Because for a UNARYOPERATOR, negating it returns a VARIABLE Formula,\n// and when you're returning a VARIABLE Formula,\n// that in fact gives you vars.\n// But, again,\n\n// TODO: Create a negate() function, like value(),\n// and have each Pattern define each Pattern's negation function --\n// a function that describes what must be true\n// for the negation to be true.\n//\n// For example, starting simply,\n// if there's a Variable Formula with a Token whose elements are \"A\",\n// then the negation function should return a state object\n// in which that variable is given a false value.\n\n// Or, better, make a setInScope function\n// in the logicParser.\n\n// See, a Node in a Tableaux has its own small scope.\n// It contains a list of things that must be true,\n// some of which are formulae, and some of which are variables.\n// !A, B, C -> D, etc.\n\n// It has to be able to create branches from its formulae,\n// one by one,\n// so it needs an array of Formulae and an internal array of branchedFormulae,\n// so that each time it branches a formula it pushes that formula onto branchedFormulae\n// to keep track of what work it has already done.\n\n// Each time it creates a branch, it gives that branch a copy of its local state.\n// See, that state defines a bunch of variables as true or false.\n// And each branch will lead to a new node,\n// which will do its own job of creating values for variables in its local state.\n\n// As soon as each node is made, and is told by the function creation it\n// what is true and what isn't,\n// it has to go through its (revised) local state and compare it to its parent.\n\n// So if the parent had a formula !A,\n// then that parent would have set \"A\" to false in its local state.\n// But if that parent also had a formula !(A->B),\n// then our new branch node will need to be created with the values {A, !B}\n\n// (Side note: Get negative scope for a material conditional\n// means getting an affirmation of the first argument\n// and a negation of the second argument.\n\n// Getting the negation of a Variable Formula\n// means simply getting an object in which that Variable's name is false.\n\n// Getting the affirmation of a Variable Formula\n// means simply getting an object in which that Variable's name is true.\n\n// For any Formula other than a Variable,\n// to get the negation or affirmation,\n// we return a Union of the key-value pairs of its arguments' scopes\n// (either negation or affirmation of each).\n\n// So negation(A->B) would return { \"A\": false, \"B\": true }\n// by returning union(negate(element[0]), affirm(element[2])).\n\n// (Element 1 is the operator itself.)\n\n/*jslint es6 */\n\n/*\n    Once you've got a parse tree, you need a way to evaluate it.\n    I.e., know if it is true or false.\n\n    Best way to do this is to define a value() function\n    (really a function that maintains, and allows access to,\n    a global state lookup table,\n    where you create entries for everything that has a known value),\n    and pass this in to the top component in your parse tree.\n\n    (This will be of type Formula.)\n\n    Most often, a Formula comprises other elements.\n    And most often, each of those elements will be a Formula.\n\n    This means each Formula needs a way to take that state-based value function\n    and use it to return its own value.\n\n    In other words: each Formula needs its own function,\n    that takes v() as an argument,\n    and uses v() to return its own value.\n\n    If a Formula is wrapped around a Variable named \"x\",\n    then its valueFunc would be (v) => v(x).\n\n    In other words: what's my value?\n    Well, it's whatever your state function says the value of \"x\" is,\n    since that's my variable.\n\n    ValueFuncs make things a bit confusing.\n    A formula needs to know which of its elements is the operator\n    and which elements are the arguments to it (if any).\n\n    The pattern is what does this, on a high level.\n\n    But specific operators need to define what their actual function is.\n    That has to happen on the Symbol level.\n    Right now, I'm using Tokens interchangeably with Symbols\n    because there's so little complexity to the logic syntax,\n    and by convention the variables have single-character names,\n    so it seems overwrought to do an entire pass to tokenize\n    and then another pass to create symbols.\n\n    Anyway, for this reason, Tokens are defining their own evaluation function.\n\n    In a nutshell:\n\n    1. A Pattern has a func that takes v() and uses it knowing \n    what the operator is and what the arguments are.\n\n    2. A Token defines a specific value func to be used by any Formula made out of it.\n\n\n    OK, so here's my dilemma.\n    I've got a Formula. To get its value, I need to get the value of each of its elements.\n\n    Base case: it's a Variable, which just returns value(varname).\n\n    Otherwise: elements[0].valueFunc(v),\n*/\n\nconst patterns = [\n  // Since we're a formula, each element in elements[] is a token or formula.\n  // The global valuation function v() will handle that.\n  new Pattern([VARIABLE], FORMULA, (matches: IMatchable[]) => \"Variable\"),\n  new Pattern(\n    [UNARYOPERATOR, FORMULA],\n    UNARYOPERATOR,\n    (matches: IMatchable[]) => matches[0].className\n  ),\n  new Pattern(\n    [FORMULA, BINARYOPERATOR, FORMULA],\n    BINARYOPERATOR,\n    (matches: IMatchable[]) => matches[1].className\n  ),\n  new Pattern(\n    [OPENPARENS, FORMULA, CLOSEPARENS],\n    FORMULA,\n    (matches: IMatchable[]) => \"Parenthetical\"\n  )\n];\n\nconst defaultState = {\n  A: true,\n  B: false\n};\n\nexport default class LogicParser {\n  public formulae: IMatchable[];\n  public foundAMatch: boolean = false;\n  constructor(public sentence: string, state: IStateDelta = defaultState) {\n    const cleanSentence = sentence.toUpperCase().replace(/\\s/g, \"\");\n    const tokens = this.tokenizeSentence(cleanSentence);\n    console.log(\"Done, and tokens is \", tokens);\n    console.log(\"-------------------\");\n    this.formulae = this.parseTokensAndFormulae(tokens);\n    console.log(\"this.formulae are \", this.formulae);\n\n    console.log(\n      \">>>>>> this.formulae[0].evaluate() is \",\n      this.formulae[0].evaluate(state)\n    );\n  }\n\n  public getRoot() {\n    if (this.formulae.length > 1) {\n      const explanation = \"Couldn't parse sentence \" + this.sentence;\n      throw new Error(explanation);\n    }\n    return this.formulae[0];\n  }\n\n  /**\n   * We want to get either true or false from this Formula,\n   * in order to build a tableau.\n   * There are various rules.\n   *\n   * For A AND B to be false, there are two possibly-true axioms:\n   * either A is false, or B is false.\n   * (We would use those to make branches.)\n   *\n   * For A AND B to be true, there are NO possibilities\n   * and two necessarily true axioms:\n   * A is true, B is true.\n   *\n   * What does it mean to say we have an axiom that A must be false?\n   * I guess it means a NOT Formula wrapped around A.\n   *\n   * And I'm thinking once we have our necessities and possibilities,\n   * we need to do a pass to look at them and see what they mean:\n   * necessities *can* set the scope in the existing node.\n   * NOT-A, if A is a Variable Formula, does set \"A\":false in the scope\n   * of the *current* Evaluation Node.\n   *\n   * NOTE: Whenever we set the value of a variable in the Evaluation Node's scope,\n   * we must *first* check for contradictions with *existing* variables in the scope.\n   * If there's a contradiction, then this Evaluation Node is CLOSED.\n   * We can stop right then and there.\n   *\n   * If there are no contradictions, then we prepare for the next level of Evaluation Nodes.\n   * We'll be handing down to each of them an array of Necessities.\n   *\n   * Here's the kicker: if there are possibilities, we hand one to each of our child Nodes.\n   * It is handed down as a Necessity.\n   * We also hand a copy of our scope to each child node.\n   *\n   * Now the child node has to go through the array of necessities\n   * and figure out what *new* necessities and possibilities they entail.\n   *\n   * So: An EvaluationNode takes a scope and an array of necessarily true formualae.\n   * First: it clones its scope, to give to its kids.\n   * Then it cycles through its necessities, one by one.\n   * For each, it gets an array of necessities and possibilities.\n   * It checks each of these child-necessities to see if it evaluates to a terminal.\n   * If so, it checks to see if any of those terminals violate its scope values.\n   *\n   * If so: TERMINATE. Closed. Finito. And you know the reason why.\n   *\n   * If not: add it to the scope you've cloned for your kids.\n   *\n   * If a given necessity doesn't violate scope, or isn't a terminal,\n   * then push it onto your next-gen necessity.\n   *\n   */\n\n  public parseTokensAndFormulae(tokens: Token[]) {\n    if (tokens.length === 0) {\n      return [];\n    }\n\n    let remainingTokens = [...tokens];\n\n    do {\n      this.foundAMatch = false;\n      for (const pattern of patterns) {\n        // We want to keep applying the pattern\n        // for as long as it is fruitful.\n\n        remainingTokens = this.substitutePatternInSentence(\n          pattern,\n          remainingTokens\n        );\n      }\n    } while (this.foundAMatch && remainingTokens.length > 1);\n\n    return remainingTokens;\n  }\n\n  /**\n   *\n   * @param {tokens}\n   * This function takes an array of tokens-or-formulae,\n   * and returns an array of tokens-or-formulae.\n   * When successful, it should replace at least one token with at least one formula.\n   * (Some formulae encompass more than one token-or-formula object,\n   * so you might replace 3 token-or-formula objects\n   * with a single new formula object.)\n   *\n   * NOTE: Not every pattern will be found in every possible sentence of tokens, of course.\n   */\n  public substitutePatternInSentence(\n    pattern: Pattern,\n    tokens: Token[]\n  ): Token[] {\n    // The design here is that we recurse.\n    // It's straight out of The Little Schemer.\n    // We return the match on the first character concat\n    // with the match on the *rest* of the characters.\n    if (tokens.length === 0) {\n      return [];\n    }\n    const matchedTokens = [];\n    let matchedPattern;\n    for (let i = 0; i < pattern.elements.length; i++) {\n      // what if the pattern happens to be longer than the sentence of tokens??\n      // It's literally impossible for this pattern to match.\n      if (i >= tokens.length) {\n        return tokens;\n      }\n      // If we hit a tokenOrFormula that doesn't match our pattern,\n      // we know this isn't a match.\n      // So we'll make a return-array with the first token at its lead,\n      // and append to it an attempted match with the *rest* of our sentence.\n      if (tokens[i].syntaxmatch !== pattern.elements[i]) {\n        return [\n          tokens[0],\n          ...this.substitutePatternInSentence(pattern, tokens.slice(1))\n        ];\n      } else {\n        matchedPattern = pattern;\n        matchedTokens.push(tokens[i]);\n      }\n    }\n\n    // Still here? Then congrats! We matched the whole pattern!\n    this.foundAMatch = true;\n    // elements, syntaxmatch, valueFunc\n    // TODO: We need to get the classname from our token here.\n    // And make sure it gets passed into our formula,\n    // so that \"!!A\" does make Not -> Not ->\n\n    if (!matchedPattern) {\n      return [];\n    }\n\n    // A Pattern's classref is a function,\n    // because the class for a pattern is different depending on which pattern it is.\n    // !A is UNARYOPERATOR, FORMULA -- so it needs to get the classref from the first object.\n    const className: string = matchedPattern.getClassName(matchedTokens);\n\n    const formula = new classRepository[className](\n      matchedTokens,\n      matchedPattern.syntaxmatch,\n      className\n    );\n\n    const remainingTokensFromMatch = tokens.slice(matchedTokens.length);\n\n    return [\n      formula,\n      ...this.substitutePatternInSentence(pattern, remainingTokensFromMatch)\n    ];\n  }\n\n  public tokenizeSentence(sentence: string): Token[] {\n    // Again, the design here is that we recurse.\n    // It's straight out of The Little Schemer.\n    // We return the match on the first character\n    // at the front of our array,\n    // and the rest of the array\n    // is the match on the *rest* of the characters.\n\n    // Recursion needs a base case.\n    // Here, if we're done (the sentence is empty), don't recurse any more!\n    if (sentence.length < 1) {\n      return [];\n    }\n    console.log(\"In tokenizeSentence, sentence is \", sentence);\n\n    let matchedToken: Token;\n    let restOfSentence: string;\n\n    for (const token of allKnownTokens) {\n      // We only care if we're matching the front of the sentence.\n      const stringToMatch: string =\n        typeof token.elements === \"string\" ? token.elements : \"#\";\n      if (sentence.indexOf(stringToMatch) === 0) {\n        matchedToken = new Token(\n          sentence.slice(0, token.elements.length),\n          token.syntaxmatch,\n          token.className\n        );\n        restOfSentence = sentence.substring(token.elements.length);\n        // Here it is: one array, with our (known) match up front\n        // and our (unknown) future matches following.\n        return [matchedToken, ...this.tokenizeSentence(restOfSentence)];\n      }\n    }\n    // This is an interesting thing -- we didn't match any of our tokens.\n    // Since our convention is that a variable name can only be one character long,\n    // we can safely make the assumption\n    // that the unmatchable character at the front of our sentence\n    // was a variable name.\n\n    matchedToken = new Token(sentence.charAt(0), VARIABLE, Variable);\n    restOfSentence = sentence.substring(1);\n    // Here it is: one array, with our (known) match up front\n    // and our (unknown) future matches following.\n    return [matchedToken, ...this.tokenizeSentence(restOfSentence)];\n  }\n}\n","import { IStateDelta } from \"App\";\nimport * as React from \"react\";\nimport styles from \"./App.module.scss\";\n\ninterface ISentenceInputState {\n  sentence: string;\n  sentences: string[];\n  stateValues: IStateDelta;\n}\n\ninterface ISentenceProps {\n  sentences: string[];\n  sentence: string;\n  stateValues: IStateDelta;\n  evaluate(\n    sentence: string,\n    stateValues: IStateDelta,\n    negateIt?: boolean\n  ): void;\n}\n\nexport class SentenceInput extends React.Component<\n  ISentenceProps,\n  ISentenceInputState\n> {\n  public trueref: HTMLInputElement | null = null;\n  public falseref: HTMLInputElement | null = null;\n  constructor(props: ISentenceProps) {\n    super(props);\n    const { sentence, sentences, stateValues } = props;\n    this.state = { sentence, sentences, stateValues };\n  }\n  public submitSentence = (e: React.MouseEvent<HTMLButtonElement>) => {\n    const { sentence, stateValues } = this.state;\n    const { evaluate } = this.props;\n    evaluate(sentence, stateValues, false);\n    (e.target as HTMLButtonElement).blur();\n  };\n\n  public submitSentenceNegated = (e: React.MouseEvent<HTMLButtonElement>) => {\n    const { sentence, stateValues } = this.state;\n    const { evaluate } = this.props;\n    evaluate(sentence, stateValues);\n    (e.target as HTMLButtonElement).blur();\n  };\n\n  public onSentenceChange = (\n    e:\n      | React.ChangeEvent<HTMLTextAreaElement>\n      | React.ChangeEvent<HTMLSelectElement>\n  ) => {\n    this.setState({ sentence: e.target.value });\n  };\n\n  public onBooleansChange = (trueOrFalse: boolean) => (\n    e: React.ChangeEvent<HTMLInputElement>\n  ) => {\n    const { stateValues } = this.state;\n\n    let newVars;\n    if (trueOrFalse) {\n      newVars = (this.trueref as HTMLInputElement).value.split(\"\");\n    } else {\n      newVars = (this.falseref as HTMLInputElement).value.split(\"\");\n    }\n\n    const newSetOfVars = newVars.reduce((acc, v) => {\n      acc[v] = trueOrFalse;\n      return acc;\n    }, {});\n    const newStateValues = { ...stateValues, ...newSetOfVars };\n    this.setState({ stateValues: newStateValues });\n  };\n\n  public render() {\n    const { sentence, sentences, stateValues } = this.state;\n    const trues = [];\n    const falses = [];\n    for (const varname of Object.keys(stateValues)) {\n      if (stateValues[varname]) {\n        trues.push(varname);\n      } else {\n        falses.push(varname);\n      }\n    }\n\n    return (\n      <div className={styles.inputsection}>\n        <div className={styles.centered}>\n          <select onChange={this.onSentenceChange} value={sentence}>\n            {sentences.map(s => (\n              <option key={s} value={s}>\n                {s}\n              </option>\n            ))}\n          </select>\n          The formula you want to test:\n          <textarea\n            cols={40}\n            rows={10}\n            onChange={this.onSentenceChange}\n            value={sentence}\n          />\n        </div>\n        <div className={styles.buttons}>\n          <button onClick={this.submitSentenceNegated}>\n            Evaluate the Negation (to make tableau)\n          </button>\n          <button onClick={this.submitSentence}>Evaluate (for 2SAT)</button>\n        </div>\n      </div>\n    );\n  }\n}\n","// tslint:disable-next-line: no-var-requires\nimport * as React from \"react\";\nimport styles from \"./App.module.scss\";\n\nimport Draggable from \"Draggable\";\nimport EvaluationNode from \"LogicParser/EvaluationNode\";\nimport { Not } from \"LogicParser/formulae/Not\";\nimport LogicParser from \"LogicParser/LogicParser\";\nimport NodeComponent from \"NodeComponent\";\nimport { IMatchable, IMatchableMap } from \"./LogicParser/Token\";\nimport { SentenceInput } from \"./SentenceInput\";\n// import {\n//   testEvaluationNode,\n//   testJsonTypes,\n//   testParserAndOperators\n// } from \"./tests\";\nconst stringify = require(\"json-stable-stringify\");\n\n(window as any).stringify = stringify;\n\n// TODO: When Using Not.wrapInNot, if it's a complex formula (i.e., not a Variable or a Not), then use parentheses!!\n\n// TODO: When a node wants to see if it is closed, its children array hasn't had all the child nodes pushed on it yet --\n// because the child node is evaluating itself before it is pushed onto the array!\n// And because of that, it is cascading upward.\n\nexport interface IStateDelta {\n  [key: string]: boolean;\n}\n\nexport interface INecessitiesAndPossibilities {\n  necessities: IMatchableMap;\n  possibilities: IMatchableMap;\n}\n\nexport interface IJSONofIMatchable {\n  elements: string | Array<IJSONofIMatchable | IMatchable>;\n  syntaxmatch: string;\n  className?: string;\n}\n\ninterface IAppState {\n  sentence: string;\n  stateValues: IStateDelta;\n  node?: EvaluationNode | null;\n}\n\nclass App extends React.Component<object, IAppState> {\n  public sentences = [\n    \"(a||!b)&&(!a||b)&&(!a||!b)&&(a||!c)\",\n    \"((A<->B)||B||A)\",\n    \"((p->q)||(r->q))->((p||r)->q)\",\n    \"((A||B)->C)->((A->C)||(B->C))\",\n    \"((A->B)||(C->D))->((A->D)||(C->B))\",\n    \"(!(A->B))->(A)\",\n    \"((A && B) -> C )->( (A -> C) || (B -> C))\",\n    \"((p<->!!q)&&(!q->(r&&!s))&&(s->(p||q)))->((s&&q)->p)\"\n  ];\n  public readonly state = {\n    node: null,\n    sentence: \"((p->q)||(r->q))->((p||r)->q)\",\n    stateValues: {}\n  };\n\n  public componentDidMount() {\n    // testJsonTypes();\n    // testParserAndOperators();\n    // testEvaluationNode();\n  }\n\n  public evaluate = (\n    sentence: string,\n    stateValues: IStateDelta,\n    negateIt: boolean = true\n  ) => {\n    // First we'll set our node to null,\n    // to flush out our previous NodeComponent.\n    window.scrollTo(0, 0);\n    this.setState({ node: null }, () => {\n      const root = new LogicParser(sentence, stateValues).getRoot();\n      let nodeToActuallyEvaluate = root;\n      if (negateIt) {\n        nodeToActuallyEvaluate = Not.wrapInNot(root);\n      }\n      const node = new EvaluationNode(\n        { [nodeToActuallyEvaluate.toString()]: nodeToActuallyEvaluate },\n        stateValues,\n        undefined,\n        false\n      );\n      node.updateStateAndGenerateChildren();\n      this.setState({ sentence, stateValues, node });\n    });\n  };\n\n  public render() {\n    const { sentence, stateValues, node } = this.state;\n    return (\n      <div className={styles.main}>\n        <Draggable>\n          {node && (\n            <NodeComponent\n              x={window.innerWidth / 2}\n              y={120}\n              node={node}\n              parent={null}\n            />\n          )}\n        </Draggable>\n\n        <SentenceInput\n          sentences={this.sentences}\n          evaluate={this.evaluate}\n          stateValues={stateValues}\n          sentence={sentence}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"./index.css\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"page\":\"App_page__1AVsN\",\"inputsection\":\"App_inputsection__2bL89\",\"centered\":\"App_centered__R4etd\",\"buttons\":\"App_buttons__1l0RY\",\"draggable\":\"App_draggable__1zP1X\",\"nodecomponent\":\"App_nodecomponent__2hdcK\",\"text\":\"App_text__372u0\",\"children\":\"App_children__Q8Kyi\"};"],"sourceRoot":""}